From 6c8c50d3f99b12f41448426beba05cac8889e2f7 Mon Sep 17 00:00:00 2001
From: Miroslav Rudisin <miero@seznam.cz>
Date: Sun, 8 Feb 2015 01:09:47 +0100
Subject: [PATCH 11/12] ASoC: botic: new adjustable generic card

---
 arch/arm/boot/dts/Makefile                   |   1 +
 arch/arm/boot/dts/am335x-bone-botic.dtsi     | 102 ++++
 arch/arm/boot/dts/am335x-bone-common.dtsi    |   5 +
 arch/arm/boot/dts/am335x-boneblack-botic.dts |  48 ++
 arch/arm/boot/dts/am335x-boneblack.dts       |   2 +
 sound/soc/davinci/Makefile                   |   1 +
 sound/soc/generic/Kconfig                    |  15 +
 sound/soc/generic/Makefile                   |   2 +
 sound/soc/generic/botic-card.c               | 772 +++++++++++++++++++++++++++
 9 files changed, 948 insertions(+)
 create mode 100644 arch/arm/boot/dts/am335x-bone-botic.dtsi
 create mode 100644 arch/arm/boot/dts/am335x-boneblack-botic.dts
 create mode 100644 sound/soc/generic/botic-card.c

diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index 4ebfa68..57ceaf9 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -397,6 +397,7 @@ dtb-$(CONFIG_SOC_AM33XX) += \
 	am335x-base0033.dtb \
 	am335x-bone.dtb \
 	am335x-boneblack.dtb \
+	am335x-boneblack-botic.dtb \
 	am335x-boneblack-replicape.dtb \
 	am335x-boneblack-ttyS5.dtb \
 	am335x-boneblack-ttyS4.dtb \
diff --git a/arch/arm/boot/dts/am335x-bone-botic.dtsi b/arch/arm/boot/dts/am335x-bone-botic.dtsi
new file mode 100644
index 0000000..7632077
--- /dev/null
+++ b/arch/arm/boot/dts/am335x-bone-botic.dtsi
@@ -0,0 +1,102 @@
+/ {
+	ocp {
+
+		P9_25_pinmux {status = "disabled"; }; /* MCLK          */
+		P9_31_pinmux {status = "disabled"; }; /* BCLK          */
+		P9_29_pinmux {status = "disabled"; }; /* LRCLK         */
+		P9_30_pinmux {status = "disabled"; }; /* DATA0         */
+		P9_41_pinmux {status = "disabled"; }; /* DATA1         */
+		P9_42_pinmux {status = "disabled"; }; /* DATA2         */
+		P9_27_pinmux {status = "disabled"; }; /* DATA3         */
+		P9_24_pinmux {status = "disabled"; }; /* MCLK_SWITCH   */
+		P9_26_pinmux {status = "disabled"; }; /* FORMAT_SWITCH */
+		P9_14_pinmux {status = "disabled"; }; /* ENABLE_SWITCH */
+	};
+
+	botic {
+		compatible = "botic-audio-card";
+		status = "okay";
+
+		pinctrl-names = "init", "default", "compat";
+		pinctrl-0 = <&botic_cape_common_pins>;
+		pinctrl-1 = <&botic_cape_common_pins &botic_cape_default_pins>;
+		pinctrl-2 = <&botic_cape_common_pins &botic_cape_compat_pins>;
+
+		audio-port = <&mcasp0>;
+
+		int-masterclk-enable = <&gpio1 27 0>;
+		ext-masterclk-switch = <&gpio0 15 0>;
+		dsd-format-switch = <&gpio0 14 0>;
+		card-power-switch = <&gpio1 18 0>;
+	};
+};
+
+&am33xx_pinmux {
+	botic_cape_common_pins: botic_cape_common_pins {
+		pinctrl-single,pins = <
+			/* onboard 24.576MHz oscillator control */
+			0x06c 0x07      /* gpmc_a11.gpio1_27,         MUX_MODE7 | PIN_OUTPUT_PULLDOWN */
+			/* external masterclock enable */
+			0x048 0x07      /* gpmc_a2.gpio1_18           MUX_MODE7 | PIN_OUTPUT_PULLDOWN */
+			/* external masterclock switch */
+			0x184 0x07      /* uart1_txd.gpio0_15         MUX_MODE7 | PIN_OUTPUT_PULLDOWN */
+			/* DSD format switch */
+			0x180 0x07      /* uart1_rxd.gpio0_14         MUX_MODE7 | PIN_OUTPUT_PULLDOWN */
+			/* master clock */
+			0x1ac 0x28      /* mcasp0_ahclkx,             MUX_MODE0 | PIN_INPUT(/OUTPUT) */
+			/* bitclock */
+			0x190 0x28      /* mcasp0_aclkx,              MUX_MODE0 | PIN_INPUT(/OUTPUT) */
+			/* wordclock */
+			0x194 0x28      /* mcasp0_fsx,                MUX_MODE0 | PIN_INPUT(/OUTPUT) */
+			/* data pins */
+			0x198 0x28      /* mcasp0_axr0,               MUX_MODE0 | PIN_INPUT(/OUTPUT) */
+			0x1a8 0x28      /* mcasp0_axr1,               MUX_MODE0 | PIN_INPUT(/OUTPUT) */
+			0x1a4 0x2a      /* mcasp0_fsr.mcasp0.axr3,    MUX_MODE2 | PIN_INPUT(/OUTPUT) */
+			/* disable CLKOUT2 to allow usage of mcasp0_axr1 on P9_42 */
+			0x1b4 0x2f      /* xdma_event_intr1.gpio0_20, MUX_MODE7 | PIN_INPUT */
+		>;
+	};
+	botic_cape_default_pins: botic_cape_default_pins {
+		/* this configuration will allow to use AHCLKR in asynchronous mode later */
+		pinctrl-single,pins = <
+			/* data pins */
+			0x1a0 0x2a      /* mcasp0_aclkr.mcasp0_axr2,  MUX_MODE2 | PIN_INPUT(/OUTPUT) */
+			/* disable eCAP0_in_PWM0_out to allow usage of mcasp0_axr2 on P9_41 */
+			0x164 0x2f      /* ecap0_in_pwm0_out.gpio0_7, MUX_MODE7 | PIN_INPUT */
+		>;
+	};
+	botic_cape_compat_pins: botic_cape_compat_pins {
+		/* compatible with original BBB setup, this output is connected also to HDMI transmitter */
+		pinctrl-single,pins = <
+			/* data pins */
+			0x19c 0x2a      /* mcasp0_ahclkr.mcasp0_axr2, MUX_MODE2 | PIN_INPUT(/OUTPUT) */
+		>;
+	};
+
+	i2c1_pins: pinmux_bb_i2c1_pins {
+		pinctrl-single,pins = <
+			0x158 0x72
+			0x15c 0x72
+		>;
+	};
+};
+
+&mcasp0 {
+	status = "okay";
+	op-mode = <0>;          /* MCASP_IIS_MODE */
+	tdm-slots = <2>;
+	num-serializer = <4>;
+	serial-dir = <  /* 0: INACTIVE, 1: TX, 2: RX */
+		1 1 1 1
+	>;
+	tx-num-evt = <16>;
+	rx-num-evt = <1>;
+};
+
+&i2c1 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c1_pins>;
+
+	clock-frequency = <100000>;
+};
diff --git a/arch/arm/boot/dts/am335x-bone-common.dtsi b/arch/arm/boot/dts/am335x-bone-common.dtsi
index e81a0ac..5bcf7c2 100644
--- a/arch/arm/boot/dts/am335x-bone-common.dtsi
+++ b/arch/arm/boot/dts/am335x-bone-common.dtsi
@@ -68,6 +68,9 @@
 };
 
 &am33xx_pinmux {
+	pinctrl-names = "default";
+	pinctrl-0 = <&clkout2_pin>;
+
 	user_leds_s0: user_leds_s0 {
 		pinctrl-single,pins = <
 			0x54 (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* gpmc_a5.gpio1_21 */
@@ -92,9 +95,11 @@
 	};
 
 	clkout2_pin: pinmux_clkout2_pin {
+#if 0
 		pinctrl-single,pins = <
 			0x1b4 (PIN_OUTPUT_PULLDOWN | MUX_MODE3)	/* xdma_event_intr1.clkout2 */
 		>;
+#endif
 	};
 
 	cpsw_default: cpsw_default {
diff --git a/arch/arm/boot/dts/am335x-boneblack-botic.dts b/arch/arm/boot/dts/am335x-boneblack-botic.dts
new file mode 100644
index 0000000..e0cea2a
--- /dev/null
+++ b/arch/arm/boot/dts/am335x-boneblack-botic.dts
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "am33xx.dtsi"
+#include "am335x-bone-common.dtsi"
+
+/ {
+	model = "TI AM335x BeagleBone Black";
+	compatible = "ti,am335x-bone-black", "ti,am335x-bone", "ti,am33xx";
+};
+
+/* Max Core Speed */
+#include "am335x-boneblack-1ghz.dtsi"
+/* #include "am335x-boneblack-800mhz.dtsi" */
+
+&ldo3_reg {
+	regulator-min-microvolt = <1800000>;
+	regulator-max-microvolt = <1800000>;
+	regulator-always-on;
+};
+
+&mmc1 {
+	vmmc-supply = <&vmmcsd_fixed>;
+};
+
+&am33xx_pinmux {
+	pinctrl-names = "default";
+	pinctrl-0 = <&clkout2_pin>;
+};
+
+#include "am335x-peripheral-emmc.dtsi"
+#include "am335x-bone-pinmux-emmc.dtsi"
+/* #include "am335x-bone-emmc-in-reset.dtsi" */
+
+#include "am335x-peripheral-nxp-hdmi.dtsi"
+#include "am335x-bone-pinmux-nxp-hdmi.dtsi"
+
+&rtc {
+	system-power-controller;
+};
+
+#include "am335x-bone-botic.dtsi"
diff --git a/arch/arm/boot/dts/am335x-boneblack.dts b/arch/arm/boot/dts/am335x-boneblack.dts
index 627b8c5..c6f6d30 100644
--- a/arch/arm/boot/dts/am335x-boneblack.dts
+++ b/arch/arm/boot/dts/am335x-boneblack.dts
@@ -62,3 +62,5 @@
 
 /* #include "am335x-peripheral-ttyS5.dtsi" */
 /* #include "am335x-bone-pinmux-ttyS5.dtsi" */
+
+#include "am335x-bone-botic.dtsi"
diff --git a/sound/soc/davinci/Makefile b/sound/soc/davinci/Makefile
index 09bf2ba..4585074 100644
--- a/sound/soc/davinci/Makefile
+++ b/sound/soc/davinci/Makefile
@@ -15,3 +15,4 @@ obj-$(CONFIG_SND_DAVINCI_SOC_VCIF) += snd-soc-davinci-vcif.o
 snd-soc-evm-objs := davinci-evm.o
 
 obj-$(CONFIG_SND_DAVINCI_SOC_GENERIC_EVM) += snd-soc-evm.o
+
diff --git a/sound/soc/generic/Kconfig b/sound/soc/generic/Kconfig
index 610f612..ab091fc 100644
--- a/sound/soc/generic/Kconfig
+++ b/sound/soc/generic/Kconfig
@@ -2,3 +2,18 @@ config SND_SIMPLE_CARD
 	tristate "ASoC Simple sound card support"
 	help
 	  This option enables generic simple sound card support
+
+config SND_BOTIC_CARD
+	tristate "ASoC Botic sound card support"
+	help
+	  This option enables Botic sound card support
+
+config SND_AM33XX_SOC_BOTIC
+	tristate "Botic on BeagleBone Black"
+	depends on SOC_AM33XX
+	select SND_BOTIC_CARD
+	select SND_EDMA_SOC
+	select SND_DAVINCI_SOC
+	select SND_DAVINCI_SOC_MCASP
+	help
+	  Say Y or M if you want to add support for Botic on BeagleBone Black.
diff --git a/sound/soc/generic/Makefile b/sound/soc/generic/Makefile
index 9c3b246..6ec89d8 100644
--- a/sound/soc/generic/Makefile
+++ b/sound/soc/generic/Makefile
@@ -1,3 +1,5 @@
 snd-soc-simple-card-objs	:= simple-card.o
+snd-soc-botic-objs	:= botic-card.o
 
 obj-$(CONFIG_SND_SIMPLE_CARD)	+= snd-soc-simple-card.o
+obj-$(CONFIG_SND_BOTIC_CARD)	+= snd-soc-botic.o
diff --git a/sound/soc/generic/botic-card.c b/sound/soc/generic/botic-card.c
new file mode 100644
index 0000000..f7ca9d7
--- /dev/null
+++ b/sound/soc/generic/botic-card.c
@@ -0,0 +1,772 @@
+/*
+ * ASoC simple sound card support
+ *
+ * Miroslav Rudisin <miero@seznam.cz>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/of_platform.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+
+#include <asm/dma.h>
+#include <asm/mach-types.h>
+
+#include <linux/edma.h>
+#include <linux/delay.h>
+
+#include <linux/of_gpio.h>
+
+#define ENABLE_EXT_MASTERCLK_44K1 1
+#define ENABLE_EXT_MASTERCLK_48K 2
+#define ENABLE_EXT_MASTERCLK_SWITCH_INVERT 4
+#define ENABLE_EXT_MASTERCLK_SINGLE 8
+
+#define ENABLE_DSD_FORMAT_SWITCH 1
+#define ENABLE_DSD_FORMAT_SWITCH_INVERT 2
+
+static int gpio_int_masterclk_enable = -1;
+static int gpio_ext_masterclk_switch = -1;
+static int gpio_dsd_format_switch = -1;
+static int gpio_card_power_switch = -1;
+
+static char *pinconfig = "default";
+static char *serconfig = "MMMM"; /* I (I2S only), D (DSD only), M (I2S and DSD), S (SPDIF) */
+
+static int ext_masterclk = ENABLE_EXT_MASTERCLK_44K1 | ENABLE_EXT_MASTERCLK_48K;
+static int dsd_format_switch = ENABLE_DSD_FORMAT_SWITCH;
+static int dai_format = SND_SOC_DAIFMT_CBS_CFS | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_I2S;
+
+static int clk_44k1 = 22579200;
+static int clk_48k = 24576000;
+static int blr_ratio = 64;
+
+/* provide codec with botic driver */
+#define ENABLE_BOTIC_CODEC
+
+#ifdef ENABLE_BOTIC_CODEC
+
+#define BOTIC_CODEC_NAME "botic-codec"
+#define BOTIC_CODEC_DAI_NAME "dac-hifi"
+
+static struct platform_device *botic_codec_platdev;
+
+static struct device_driver botic_codec_devdrv = {
+    .name = "botic-codec-devdrv",
+};
+
+static struct snd_soc_dai_driver botic_dac_dai = {
+    .name = BOTIC_CODEC_DAI_NAME,
+    .playback = {
+        .stream_name = "Playback",
+        .channels_min = 2,
+        .channels_max = 8,
+        .rates =
+            SNDRV_PCM_RATE_CONTINUOUS |
+            SNDRV_PCM_RATE_11025 |
+            SNDRV_PCM_RATE_22050 |
+            SNDRV_PCM_RATE_44100 |
+            SNDRV_PCM_RATE_88200 |
+            SNDRV_PCM_RATE_176400 |
+            SNDRV_PCM_RATE_352800 |
+            SNDRV_PCM_RATE_705600 |
+            SNDRV_PCM_RATE_16000 |
+            SNDRV_PCM_RATE_32000 |
+            SNDRV_PCM_RATE_48000 |
+            SNDRV_PCM_RATE_96000 |
+            SNDRV_PCM_RATE_192000 |
+            SNDRV_PCM_RATE_384000 |
+            SNDRV_PCM_RATE_768000 |
+            0,
+        .formats =
+            SNDRV_PCM_FMTBIT_S16_LE |
+            SNDRV_PCM_FMTBIT_S16_BE |
+            SNDRV_PCM_FMTBIT_S24_3LE |
+            SNDRV_PCM_FMTBIT_S24_3BE |
+            SNDRV_PCM_FMTBIT_S24_LE |
+            SNDRV_PCM_FMTBIT_S24_BE |
+            SNDRV_PCM_FMTBIT_S32_LE |
+            SNDRV_PCM_FMTBIT_S32_BE |
+            SNDRV_PCM_FMTBIT_DSD_U8 |
+            SNDRV_PCM_FMTBIT_DSD_U16_LE |
+            SNDRV_PCM_FMTBIT_DSD_U16_BE |
+            SNDRV_PCM_FMTBIT_DSD_U32_LE |
+            SNDRV_PCM_FMTBIT_DSD_U32_BE |
+            0,
+    },
+};
+
+static struct snd_soc_codec_driver botic_codec_socdrv = {
+};
+
+static int botic_codec_socdrv_registered;
+
+#endif
+
+static int is_dsd(snd_pcm_format_t format)
+{
+    switch (format) {
+        case SNDRV_PCM_FORMAT_DSD_U8:
+        case SNDRV_PCM_FORMAT_DSD_U16_LE:
+        case SNDRV_PCM_FORMAT_DSD_U16_BE:
+        case SNDRV_PCM_FORMAT_DSD_U32_LE:
+        case SNDRV_PCM_FORMAT_DSD_U32_BE:
+            return 1;
+            break;
+
+        default:
+            return 0;
+            break;
+    }
+}
+
+struct botic_ser_setup {
+    int dai_fmt;
+    int nch_tx;
+    int tx_slots[4];
+    int nch_rx;
+    int rx_slots[4];
+};
+
+static int botic_setup_serializers(struct snd_soc_dai *cpu_dai,
+        snd_pcm_format_t format, struct botic_ser_setup *ser_setup)
+{
+    int n_i2s = 0;
+    int n_dsd = 0;
+    int n_spdif = 0;
+    int i;
+    int ret;
+
+    /* clear serializer setup */
+    memset(ser_setup, 0, sizeof(*ser_setup));
+
+    for (i = 0; i < 4; i++) {
+        switch (serconfig[i]) {
+            case 'I':
+                if (is_dsd(format)) continue;
+                n_i2s++;
+                break;
+            case 'D':
+                if (!is_dsd(format)) continue;
+                n_dsd++;
+                break;
+            case 'M':
+                n_i2s++;
+                n_dsd++;
+                break;
+            case 'S':
+                n_spdif++;
+                break;
+            case 'R':
+                ser_setup->rx_slots[ser_setup->nch_rx++] = i;
+                continue;
+            case '-':
+                continue;
+            default:
+                printk(KERN_ERR "botic-card: invalid character '%c'"
+                       " in serconfig\n", serconfig[i]);
+                return -EINVAL;
+                break;
+        }
+        ser_setup->tx_slots[ser_setup->nch_tx++] = i;
+    }
+
+    if (n_spdif > 0 && (n_i2s + n_dsd) != 0) {
+        printk(KERN_ERR "botic-card: SPDIF cannot be combined with other formats");
+        return -EINVAL;
+    }
+
+    if (n_dsd == 0 && is_dsd(format)) {
+        printk(KERN_ERR "botic-card: no pins for DSD playback");
+        return -EINVAL;
+    }
+
+    ret = snd_soc_dai_set_channel_map(cpu_dai, ser_setup->nch_tx,
+            ser_setup->tx_slots, ser_setup->nch_rx, ser_setup->rx_slots);
+    if (ret < 0)
+        return ret;
+
+    ser_setup->dai_fmt = dai_format;
+    if (n_spdif > 0) {
+#if 1
+        ser_setup->dai_fmt = SND_SOC_DAIFMT_DIT;
+#else
+        printk(KERN_ERR "botic-card: DIT is not supported dai format");
+        return -EINVAL;
+#endif
+    }
+
+    return 0;
+}
+
+static int botic_hw_params(struct snd_pcm_substream *substream,
+             struct snd_pcm_hw_params *params)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    unsigned sysclk, bclk, divisor;
+    struct botic_ser_setup ser_setup;
+    int ret;
+
+    snd_pcm_format_t format = params_format(params);
+    unsigned int rate = params_rate(params);
+
+    /* setup CPU serializers */
+    ret = botic_setup_serializers(cpu_dai, format, &ser_setup);
+    if (ret < 0)
+        return ret;
+
+    /* set codec DAI configuration */
+    ret = snd_soc_dai_set_fmt(codec_dai, ser_setup.dai_fmt);
+    if ((ret < 0) && (ret != -ENOTSUPP))
+        return ret;
+
+    /* set cpu DAI configuration */
+    ret = snd_soc_dai_set_fmt(cpu_dai, ser_setup.dai_fmt);
+    if (ret < 0)
+        return ret;
+
+    /* select correct clock for requested sample rate */
+    if ((clk_44k1 != 0) && (clk_44k1 % rate == 0)) {
+        sysclk = clk_44k1;
+        if (gpio_int_masterclk_enable >= 0) {
+            gpio_set_value(gpio_int_masterclk_enable, 0);
+        }
+        if (gpio_ext_masterclk_switch >= 0) {
+            /* set level to LOW for 44k1 sampling rates */
+            gpio_set_value(gpio_ext_masterclk_switch,
+                    !!(ext_masterclk & ENABLE_EXT_MASTERCLK_SWITCH_INVERT));
+        }
+    } else if (clk_48k % rate == 0) {
+        sysclk = clk_48k;
+        if (gpio_ext_masterclk_switch >= 0) {
+            /* set level to HIGH for 48k sampling rates */
+            gpio_set_value(gpio_ext_masterclk_switch,
+                    !(ext_masterclk & ENABLE_EXT_MASTERCLK_SWITCH_INVERT));
+        }
+        if ((gpio_int_masterclk_enable >= 0) &&
+                !(ext_masterclk & ENABLE_EXT_MASTERCLK_48K)) {
+            /* 44k1 clock is disabled now, we can enable onboard clock */
+            gpio_set_value(gpio_int_masterclk_enable, 1);
+        }
+    } else if ((dai_format & SND_SOC_DAIFMT_CBM_CFM) == 0) {
+        printk("unsupported rate %d\n", rate);
+        return -EINVAL;
+    } else {
+        printk("slave rate %d\n", rate);
+        sysclk = 0;
+    }
+
+    /* setup DSD format switch */
+    if (!(dsd_format_switch & ENABLE_DSD_FORMAT_SWITCH) ||
+        (gpio_dsd_format_switch < 0)) {
+        /* DSD format switch is disabled or not available */
+    } else if (is_dsd(params_format(params))) {
+        /* DSD format switch is enabled, set level to HIGH for DSD playback */
+        gpio_set_value(gpio_dsd_format_switch,
+                !(dsd_format_switch & ENABLE_DSD_FORMAT_SWITCH_INVERT));
+    } else {
+        /* DSD format switch is enabled, set level to LOW for PCM playback */
+        gpio_set_value(gpio_dsd_format_switch,
+                !!(dsd_format_switch & ENABLE_DSD_FORMAT_SWITCH_INVERT));
+    }
+
+    /* set the codec system clock */
+    ret = snd_soc_dai_set_sysclk(codec_dai, 0, sysclk, SND_SOC_CLOCK_IN);
+    if ((ret < 0) && (ret != -ENOTSUPP))
+        return ret;
+
+    /* use the external clock */
+    ret = snd_soc_dai_set_sysclk(cpu_dai, 0, sysclk, SND_SOC_CLOCK_IN);
+    if (ret < 0) {
+        printk(KERN_WARNING "botic-card: unable to set clock to CPU; ret=%d", ret);
+        return ret;
+    }
+
+    ret = snd_soc_dai_set_clkdiv(cpu_dai, 0, 1);
+    if (ret < 0) {
+        printk(KERN_WARNING "botic-card: unsupported set_clkdiv0");
+        return ret;
+    }
+
+    if ((dai_format & SND_SOC_DAIFMT_CBM_CFM) != 0) {
+        printk("slave mode...\n");
+        return 0;
+    }
+
+    switch (params_format(params)) {
+        case SNDRV_PCM_FORMAT_DSD_U8:
+            /* Clock rate for DSD matches bitrate */
+            ret = snd_soc_dai_set_clkdiv(cpu_dai, 2, 0);
+            bclk = 8 * rate;
+            break;
+
+        case SNDRV_PCM_FORMAT_DSD_U16_LE:
+        case SNDRV_PCM_FORMAT_DSD_U16_BE:
+            /* Clock rate for DSD matches bitrate */
+            ret = snd_soc_dai_set_clkdiv(cpu_dai, 2, 0);
+            bclk = 16 * rate;
+            break;
+
+        case SNDRV_PCM_FORMAT_DSD_U32_LE:
+        case SNDRV_PCM_FORMAT_DSD_U32_BE:
+            /* Clock rate for DSD matches bitrate */
+            ret = snd_soc_dai_set_clkdiv(cpu_dai, 2, 0);
+            bclk = 32 * rate;
+            break;
+
+        default:
+            /* PCM */
+            ret = snd_soc_dai_set_clkdiv(cpu_dai, 2, blr_ratio);
+            if (blr_ratio != 0) {
+                bclk = blr_ratio * rate;
+            } else {
+                bclk = snd_soc_params_to_bclk(params);
+            }
+            break;
+    }
+    if (ret < 0) {
+        printk(KERN_WARNING "botic-card: unsupported BCLK/LRCLK ratio");
+        return ret;
+    }
+
+    divisor = (sysclk + (bclk / 2)) / bclk;
+    ret = snd_soc_dai_set_clkdiv(cpu_dai, 1, divisor);
+    if (ret < 0) {
+        printk(KERN_WARNING "botic-card: unsupported set_clkdiv1");
+        return ret;
+    }
+
+    /* Insert delay needed for enabled clocks. */
+    udelay(50);
+
+    return 0;
+}
+
+static struct snd_soc_ops botic_ops = {
+    .hw_params = botic_hw_params,
+};
+
+/* digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link botic_dai = {
+    .name = "ExtDAC",
+    .stream_name = "external",
+    .ops = &botic_ops,
+};
+
+static struct snd_soc_card botic_card = {
+    .name = "Botic",
+    .owner = THIS_MODULE,
+    .dai_link = &botic_dai,
+    .num_links = 1,
+};
+
+static int get_optional_gpio(int *optional_gpio, struct platform_device *pdev,
+        const char *gpio_name, unsigned long gpio_flags)
+{
+    struct device_node *np = pdev->dev.of_node;
+    struct property *p;
+    int lp;
+    int ret;
+    int gpio;
+
+    p = of_find_property(np, gpio_name, &lp);
+    if (!p) {
+        dev_err(&pdev->dev, "entry for %s does not exist\n", gpio_name);
+        return -ENOENT;
+    }
+
+    if (lp == 0) {
+        *optional_gpio = -1;
+        return 0;
+    }
+
+    ret = of_get_named_gpio(np, gpio_name, 0);
+    if (ret < 0) {
+        dev_err(&pdev->dev, "failed to read GPIO for %s\n", gpio_name);
+        return ret;
+    }
+
+    gpio = ret;
+    ret = gpio_request_one(gpio, gpio_flags, gpio_name);
+    if (ret < 0) {
+        dev_err(&pdev->dev, "failed to claim GPIO for %s\n", gpio_name);
+        return ret;
+    }
+
+    *optional_gpio = gpio;
+
+    return 0;
+}
+
+#if defined(CONFIG_OF)
+
+static int asoc_botic_card_probe(struct platform_device *pdev)
+{
+    struct device_node *np = pdev->dev.of_node;
+    struct pinctrl *pctl;
+    struct pinctrl_state *pctl_state;
+    int ret;
+
+    /* load selected pinconfig */
+    pctl = devm_pinctrl_get(&pdev->dev);
+    if (IS_ERR(pctl)) {
+        ret = PTR_ERR(pctl);
+        goto asoc_botic_card_probe_error;
+    }
+    pctl_state = pinctrl_lookup_state(pctl, pinconfig);
+    if (IS_ERR(pctl_state)) {
+        dev_err(&pdev->dev, "unable to lookup pinconfig %s\n", pinconfig);
+        ret = PTR_ERR(pctl_state);
+        goto asoc_botic_card_probe_error;
+    }
+    ret = pinctrl_select_state(pctl, pctl_state);
+    if (ret < 0) {
+        dev_err(&pdev->dev, "unable to set pinconfig %s\n", pinconfig);
+        goto asoc_botic_card_probe_error;
+    }
+    dev_info(&pdev->dev, "using '%s' pinconfig\n", pinconfig);
+
+    /*
+     * TODO: Move GPIO handling out of the probe, if probe gets
+     * deferred, the gpio will have been claimed on previous
+     * probe and will fail on the second and susequent probes
+     */
+
+    /* request GPIO to control internal 24.576MHz oscillator */
+    ret = get_optional_gpio(&gpio_int_masterclk_enable, pdev,
+            "int-masterclk-enable", GPIOF_OUT_INIT_LOW);
+    if (ret < 0) {
+        goto asoc_botic_card_probe_error;
+    }
+
+    /* request GPIO to card power switch */
+    ret = get_optional_gpio(&gpio_card_power_switch, pdev,
+            "card-power-switch", GPIOF_OUT_INIT_LOW);
+    if (ret < 0) {
+        goto asoc_botic_card_probe_error;
+    }
+
+    if (ext_masterclk & (ENABLE_EXT_MASTERCLK_44K1 | ENABLE_EXT_MASTERCLK_48K)) {
+        /* request GPIO to switch between external 22.5792MHz and 24.576MHz oscillators */
+        ret = get_optional_gpio(&gpio_ext_masterclk_switch, pdev,
+                "ext-masterclk-switch", GPIOF_OUT_INIT_HIGH);
+        if (ret < 0) {
+            goto asoc_botic_card_probe_error;
+        }
+        switch (ext_masterclk & (ENABLE_EXT_MASTERCLK_44K1 | ENABLE_EXT_MASTERCLK_48K)) {
+            case ENABLE_EXT_MASTERCLK_44K1:
+                if (ext_masterclk & ENABLE_EXT_MASTERCLK_SINGLE) {
+                    clk_48k = 0;
+                } else {
+                    /* fallback to internal oscillator */
+                }
+                break;
+            case ENABLE_EXT_MASTERCLK_48K:
+                clk_44k1 = 0;
+                break;
+            case ENABLE_EXT_MASTERCLK_44K1 | ENABLE_EXT_MASTERCLK_48K:
+                /* use both oscillators */
+                break;
+        }
+    } else {
+        ext_masterclk = 0;
+        gpio_ext_masterclk_switch = -1;
+        /* TODO: which clock to disable */
+        clk_44k1 = 0;
+    }
+
+    if (dsd_format_switch & ENABLE_DSD_FORMAT_SWITCH) {
+        ret = get_optional_gpio(&gpio_dsd_format_switch, pdev,
+                "dsd-format-switch", GPIOF_OUT_INIT_HIGH);
+        if (ret < 0) {
+            goto asoc_botic_card_probe_error;
+        }
+    } else {
+        dsd_format_switch = 0;
+        gpio_dsd_format_switch = -1;
+    }
+
+    botic_dai.codec_of_node = of_parse_phandle(np, "audio-codec", 0);
+    if (botic_dai.codec_of_node) {
+        ret = of_property_read_string_index(np, "audio-codec-dai", 0,
+                &botic_dai.codec_dai_name);
+        if (ret < 0) {
+            goto asoc_botic_card_probe_error;
+        }
+    } else {
+#ifdef ENABLE_BOTIC_CODEC
+        ret = snd_soc_register_codec(&botic_codec_platdev->dev,
+                &botic_codec_socdrv, &botic_dac_dai, 1);
+        if (ret < 0) {
+            goto asoc_botic_card_probe_error;
+        }
+        botic_dai.codec_name = BOTIC_CODEC_NAME;
+        botic_dai.codec_dai_name = BOTIC_CODEC_DAI_NAME;
+        botic_codec_socdrv_registered = 1;
+#else
+        ret = -ENOENT;
+        goto asoc_botic_card_probe_error;
+#endif
+    }
+
+    botic_dai.cpu_of_node = of_parse_phandle(np, "audio-port", 0);
+    if (!botic_dai.cpu_of_node) {
+        ret = -ENOENT;
+        goto asoc_botic_card_probe_error;
+    }
+
+    /* TODO */
+    botic_dai.platform_of_node = botic_dai.cpu_of_node;
+
+    botic_card.dev = &pdev->dev;
+
+    /* register card */
+    ret = snd_soc_register_card(&botic_card);
+    if (ret) {
+        dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n", ret);
+        goto asoc_botic_card_probe_error;
+    }
+
+    /* a hack for removing unsupported rates from the codec */
+    if (clk_44k1 == 0) {
+        botic_card.rtd[0].codec_dai->driver->playback.rates &=
+            ~(SNDRV_PCM_RATE_5512 | SNDRV_PCM_RATE_11025 |
+              SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_44100 |
+              SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_176400 |
+              SNDRV_PCM_RATE_352800 | SNDRV_PCM_RATE_705600 |
+              0);
+    }
+    if (clk_48k == 0) {
+        botic_card.rtd[0].codec_dai->driver->playback.rates &=
+            ~(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |
+              SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_48000 |
+              SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000 |
+              SNDRV_PCM_RATE_384000 | SNDRV_PCM_RATE_768000 |
+              0);
+    }
+
+    dev_info(&pdev->dev, "48k %s, 44k1 %s, %s format switch\n",
+            (ext_masterclk & ENABLE_EXT_MASTERCLK_48K) ? "ext" : (
+                clk_48k != 0 ? "int" : "none"),
+            (ext_masterclk & ENABLE_EXT_MASTERCLK_44K1) ? "ext" : "none",
+            (dsd_format_switch & ENABLE_DSD_FORMAT_SWITCH) ? "use" : "do not use");
+
+    if (gpio_card_power_switch >= 0) {
+        /* switch the card on */
+        gpio_set_value(gpio_card_power_switch, 1);
+    }
+
+asoc_botic_card_probe_error:
+    if (ret != 0) {
+#ifdef ENABLE_BOTIC_CODEC
+        if (botic_codec_socdrv_registered) {
+            snd_soc_unregister_codec(&botic_codec_platdev->dev);
+            botic_codec_socdrv_registered = 0;
+        }
+#endif
+        if (gpio_int_masterclk_enable >= 0) {
+            gpio_free(gpio_int_masterclk_enable);
+        }
+        if (gpio_card_power_switch >= 0) {
+            gpio_free(gpio_card_power_switch);
+        }
+        if (gpio_ext_masterclk_switch >= 0) {
+            gpio_free(gpio_ext_masterclk_switch);
+        }
+        if (gpio_dsd_format_switch >= 0) {
+            gpio_free(gpio_dsd_format_switch);
+        }
+    }
+
+    return ret;
+}
+
+static int asoc_botic_card_remove(struct platform_device *pdev)
+{
+    struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+#ifdef ENABLE_BOTIC_CODEC
+    if (botic_codec_socdrv_registered) {
+        snd_soc_unregister_codec(&botic_codec_platdev->dev);
+        botic_codec_socdrv_registered = 0;
+    }
+#endif
+
+    snd_soc_unregister_card(card);
+
+    if (gpio_int_masterclk_enable >= 0) {
+        /* switch the oscillator off first */
+        gpio_set_value(gpio_int_masterclk_enable, 0);
+        gpio_free(gpio_int_masterclk_enable);
+    }
+    if (gpio_card_power_switch >= 0) {
+        /* switch the card off first */
+        gpio_set_value(gpio_card_power_switch, 0);
+        gpio_free(gpio_card_power_switch);
+    }
+    if (gpio_ext_masterclk_switch >= 0) {
+        gpio_free(gpio_ext_masterclk_switch);
+    }
+    if (gpio_dsd_format_switch >= 0) {
+        gpio_free(gpio_dsd_format_switch);
+    }
+
+    return 0;
+}
+
+static void asoc_botic_card_shutdown(struct platform_device *pdev)
+{
+    if (gpio_card_power_switch >= 0) {
+        /* switch the card off first */
+        gpio_set_value(gpio_card_power_switch, 0);
+        /* sleep until card will be powered down safely */
+        mdelay(1000);
+    }
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int asoc_botic_card_suspend(struct platform_device *pdev, pm_message_t state)
+{
+    if (gpio_card_power_switch >= 0) {
+        /* switch the card off before going suspend */
+        gpio_set_value(gpio_card_power_switch, 0);
+    }
+
+    return 0;
+}
+
+static int asoc_botic_card_resume(struct platform_device *pdev)
+{
+    if (gpio_card_power_switch >= 0) {
+        /* switch the card on after resuming from suspend */
+        gpio_set_value(gpio_card_power_switch, 1);
+    }
+
+    return 0;
+}
+#else
+#define asoc_botic_card_suspend NULL
+#define asoc_botic_card_resume NULL
+#endif
+
+static const struct of_device_id asoc_botic_card_dt_ids[] = {
+    { .compatible = "botic-audio-card" },
+    { },
+};
+
+MODULE_DEVICE_TABLE(of, asoc_botic_card_dt_ids);
+
+static struct platform_driver asoc_botic_card_driver = {
+    .probe = asoc_botic_card_probe,
+    .remove = asoc_botic_card_remove,
+    .shutdown = asoc_botic_card_shutdown,
+    .suspend = asoc_botic_card_suspend,
+    .resume = asoc_botic_card_resume,
+    .driver = {
+        .name = "asoc-botic-card",
+        .owner = THIS_MODULE,
+        .of_match_table = of_match_ptr(asoc_botic_card_dt_ids),
+    },
+};
+#endif
+
+static struct platform_device *botic_card_device;
+
+static int __init botic_init(void)
+{
+    int ret;
+
+#ifdef ENABLE_BOTIC_CODEC
+    botic_codec_platdev = platform_device_alloc(BOTIC_CODEC_NAME, PLATFORM_DEVID_NONE);
+    if (!botic_codec_platdev)
+        return -ENOMEM;
+
+    ret = platform_device_add(botic_codec_platdev);
+    if (ret) {
+        platform_device_put(botic_codec_platdev);
+        ret = -EINVAL;
+    }
+
+    botic_codec_platdev->dev.driver = &botic_codec_devdrv;
+#endif
+
+#if defined(CONFIG_OF)
+    /*
+     * If dtb is there, the devices will be created dynamically.
+     * Only register platfrom driver structure.
+     */
+    if (of_have_populated_dt())
+        return platform_driver_register(&asoc_botic_card_driver);
+#endif
+
+    botic_card_device = platform_device_alloc("soc-audio", 0);
+    if (!botic_card_device)
+        return -ENOMEM;
+
+    platform_set_drvdata(botic_card_device, &botic_card);
+    ret = platform_device_add(botic_card_device);
+    if (ret)
+        platform_device_put(botic_card_device);
+
+    return ret;
+}
+
+static void __exit botic_exit(void)
+{
+#ifdef ENABLE_BOTIC_CODEC
+    platform_device_unregister(botic_codec_platdev);
+#endif
+
+#if defined(CONFIG_OF)
+    if (of_have_populated_dt()) {
+        platform_driver_unregister(&asoc_botic_card_driver);
+        return;
+    }
+#endif
+
+    platform_device_unregister(botic_card_device);
+}
+
+module_init(botic_init);
+module_exit(botic_exit);
+
+module_param(pinconfig, charp, 0444);
+MODULE_PARM_DESC(pinconfig, "selected pin configuration");
+
+module_param(ext_masterclk, int, 0444);
+MODULE_PARM_DESC(ext_masterclk, "available external masterclocks");
+
+module_param(dsd_format_switch, int, 0444);
+MODULE_PARM_DESC(dsd_format_switch, "mode of dsd format switch");
+
+module_param(serconfig, charp, 0644);
+MODULE_PARM_DESC(serconfig, "serializer configuration");
+
+module_param(dai_format, int, 0644);
+MODULE_PARM_DESC(dai_format, "output format and clock sources configuration");
+
+module_param(clk_44k1, int, 0644);
+MODULE_PARM_DESC(clk_44k1, "frequency of crystal for 44k1 modes");
+
+module_param(clk_48k, int, 0644);
+MODULE_PARM_DESC(clk_48k, "frequency of crystal for 48k modes");
+
+module_param(blr_ratio, int, 0644);
+MODULE_PARM_DESC(blr_ratio, "force BCLK/LRCLK ratio");
+
+MODULE_AUTHOR("Miroslav Rudisin");
+MODULE_DESCRIPTION("ASoC Botic sound card");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:asoc-botic-card");
-- 
2.1.4

