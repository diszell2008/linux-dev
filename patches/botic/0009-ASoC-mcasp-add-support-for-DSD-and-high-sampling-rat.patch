From 953c96d833f61c3824872eec1be2533bbb015304 Mon Sep 17 00:00:00 2001
From: Miroslav Rudisin <miero@seznam.cz>
Date: Wed, 27 Aug 2014 23:29:49 +0200
Subject: [PATCH 09/12] ASoC: mcasp: add support for DSD and high sampling
 rates

---
 sound/soc/davinci/davinci-mcasp.c | 87 +++++++++++++++++++++++++++++++++++----
 1 file changed, 78 insertions(+), 9 deletions(-)

diff --git a/sound/soc/davinci/davinci-mcasp.c b/sound/soc/davinci/davinci-mcasp.c
index b7d98ba..7f7a8e9 100644
--- a/sound/soc/davinci/davinci-mcasp.c
+++ b/sound/soc/davinci/davinci-mcasp.c
@@ -638,14 +638,14 @@ static int davinci_config_channel_size(struct davinci_mcasp *mcasp,
 }
 
 static int mcasp_common_hw_param(struct davinci_mcasp *mcasp, int stream,
-				 int period_words, int channels)
+				 int period_words, int channels, u8 dsd_mode)
 {
 	struct davinci_pcm_dma_params *dma_params = &mcasp->dma_params[stream];
 	struct snd_dmaengine_dai_dma_data *dma_data = &mcasp->dma_data[stream];
 	int i;
 	u8 tx_ser = 0;
 	u8 rx_ser = 0;
-	u8 slots = mcasp->tdm_slots;
+	u8 slots = dsd_mode ? 1 : mcasp->tdm_slots;
 	u8 max_active_serializers = (channels + slots - 1) / slots;
 	int active_serializers, numevt, n;
 	u32 reg;
@@ -750,13 +750,24 @@ static int mcasp_common_hw_param(struct davinci_mcasp *mcasp, int stream,
 }
 
 static int mcasp_i2s_hw_param(struct davinci_mcasp *mcasp, int stream,
-			      int channels)
+			      int channels, u8 dsd_mode)
 {
 	int i, active_slots;
 	int total_slots;
 	int active_serializers;
 	u32 mask = 0;
 	u32 busel = 0;
+	u32 mod;
+
+	/* TODO */
+#if 0
+	if ((mcasp->tdm_slots < 1) || (mcasp->tdm_slots > 32) ||
+		((!dsd_mode && (mcasp->tdm_slots % 2 != 0)))) {
+		dev_err(mcasp->dev, "tdm slot %d not supported\n",
+			mcasp->tdm_slots);
+		return -EINVAL;
+	}
+#endif
 
 	total_slots = mcasp->tdm_slots;
 
@@ -772,6 +783,14 @@ static int mcasp_i2s_hw_param(struct davinci_mcasp *mcasp, int stream,
 	else
 		active_slots = total_slots;
 
+	if (dsd_mode) {
+		printk("DSD active_slots=%d\n", active_slots);
+	}
+	/* TODO */
+#if 0
+	active_slots = (mcasp->tdm_slots > 31) ? 32 : mcasp->tdm_slots;
+#endif
+
 	for (i = 0; i < active_slots; i++)
 		mask |= (1 << i);
 
@@ -780,15 +799,26 @@ static int mcasp_i2s_hw_param(struct davinci_mcasp *mcasp, int stream,
 	if (!mcasp->dat_port)
 		busel = TXSEL;
 
+	if (dsd_mode) {
+		mask = 1;
+		busel = 0;
+		mod = 0;
+	} else {
+		mod = total_slots;
+	}
+
 	mcasp_set_reg(mcasp, DAVINCI_MCASP_TXTDM_REG, mask);
 	mcasp_set_bits(mcasp, DAVINCI_MCASP_TXFMT_REG, busel | TXORD);
 	mcasp_mod_bits(mcasp, DAVINCI_MCASP_TXFMCTL_REG,
-		       FSXMOD(total_slots), FSXMOD(0x1FF));
+		       FSXMOD(mod), FSXMOD(0x1FF));
 
 	mcasp_set_reg(mcasp, DAVINCI_MCASP_RXTDM_REG, mask);
 	mcasp_set_bits(mcasp, DAVINCI_MCASP_RXFMT_REG, busel | RXORD);
 	mcasp_mod_bits(mcasp, DAVINCI_MCASP_RXFMCTL_REG,
-		       FSRMOD(total_slots), FSRMOD(0x1FF));
+		       FSRMOD(mod), FSRMOD(0x1FF));
+
+	/* Disable the DIT */
+	mcasp_clr_bits(mcasp, DAVINCI_MCASP_TXDITCTL_REG, DITEN);
 
 	return 0;
 }
@@ -864,6 +894,23 @@ static int mcasp_dit_hw_param(struct davinci_mcasp *mcasp,
 	return 0;
 }
 
+static int is_dsd(snd_pcm_format_t format)
+{
+	switch (format) {
+		case SNDRV_PCM_FORMAT_DSD_U8:
+		case SNDRV_PCM_FORMAT_DSD_U16_LE:
+		case SNDRV_PCM_FORMAT_DSD_U16_BE:
+		case SNDRV_PCM_FORMAT_DSD_U32_LE:
+		case SNDRV_PCM_FORMAT_DSD_U32_BE:
+			return 1;
+			break;
+
+		default:
+			return 0;
+			break;
+	}
+}
+
 static int davinci_mcasp_hw_params(struct snd_pcm_substream *substream,
 					struct snd_pcm_hw_params *params,
 					struct snd_soc_dai *cpu_dai)
@@ -872,10 +919,14 @@ static int davinci_mcasp_hw_params(struct snd_pcm_substream *substream,
 	struct davinci_pcm_dma_params *dma_params =
 					&mcasp->dma_params[substream->stream];
 	int word_length;
+	bool dsd_mode = is_dsd(params_format(params));
 	int channels = params_channels(params);
 	int period_size = params_period_size(params);
 	int ret;
 
+	if (dsd_mode && mcasp->op_mode == DAVINCI_MCASP_DIT_MODE)
+		return -EINVAL;
+
 	/*
 	 * If mcasp is BCLK master, and a BCLK divider was not provided by
 	 * the machine driver, we need to calculate the ratio.
@@ -895,7 +946,7 @@ static int davinci_mcasp_hw_params(struct snd_pcm_substream *substream,
 	}
 
 	ret = mcasp_common_hw_param(mcasp, substream->stream,
-				    period_size * channels, channels);
+				    period_size * channels, channels, dsd_mode);
 	if (ret)
 		return ret;
 
@@ -903,7 +954,7 @@ static int davinci_mcasp_hw_params(struct snd_pcm_substream *substream,
 		ret = mcasp_dit_hw_param(mcasp, params_rate(params));
 	else
 		ret = mcasp_i2s_hw_param(mcasp, substream->stream,
-					 channels);
+					 channels, dsd_mode);
 
 	if (ret)
 		return ret;
@@ -939,6 +990,21 @@ static int davinci_mcasp_hw_params(struct snd_pcm_substream *substream,
 		word_length = 32;
 		break;
 
+	case SNDRV_PCM_FORMAT_DSD_U8:
+		dma_params->data_type = 1;
+		word_length = 8;
+		break;
+
+	case SNDRV_PCM_FORMAT_DSD_U16_LE:
+		dma_params->data_type = 2;
+		word_length = 16;
+		break;
+
+	case SNDRV_PCM_FORMAT_DSD_U32_LE:
+		dma_params->data_type = 4;
+		word_length = 32;
+		break;
+
 	default:
 		printk(KERN_WARNING "davinci-mcasp: unsupported PCM format");
 		return -EINVAL;
@@ -1177,7 +1243,7 @@ static int davinci_mcasp_resume(struct snd_soc_dai *dai)
 #define davinci_mcasp_resume NULL
 #endif
 
-#define DAVINCI_MCASP_RATES	SNDRV_PCM_RATE_8000_192000
+#define DAVINCI_MCASP_RATES	(SNDRV_PCM_RATE_8000_768000 | SNDRV_PCM_RATE_CONTINUOUS)
 
 #define DAVINCI_MCASP_PCM_FMTS (SNDRV_PCM_FMTBIT_S8 | \
 				SNDRV_PCM_FMTBIT_U8 | \
@@ -1188,7 +1254,10 @@ static int davinci_mcasp_resume(struct snd_soc_dai *dai)
 				SNDRV_PCM_FMTBIT_S24_3LE | \
 				SNDRV_PCM_FMTBIT_U24_3LE | \
 				SNDRV_PCM_FMTBIT_S32_LE | \
-				SNDRV_PCM_FMTBIT_U32_LE)
+				SNDRV_PCM_FMTBIT_U32_LE | \
+				SNDRV_PCM_FMTBIT_DSD_U8 | \
+				SNDRV_PCM_FMTBIT_DSD_U16_LE | \
+				SNDRV_PCM_FMTBIT_DSD_U32_LE)
 
 static struct snd_soc_dai_driver davinci_mcasp_dai[] = {
 	{
-- 
2.1.4

