From 0d0eef29f3b3b5f9cb1e70a512b9396a6974224c Mon Sep 17 00:00:00 2001
From: Miroslav Rudisin <miero@seznam.cz>
Date: Sat, 7 Feb 2015 20:00:22 +0100
Subject: [PATCH 02/12] pm: schedule shutdown on power loss

---
 drivers/mfd/tps65217.c | 94 +++++++++++++++++++++++++++++++++-----------------
 drivers/rtc/rtc-omap.c | 44 ++++++++++++++---------
 include/linux/pm.h     |  1 +
 3 files changed, 91 insertions(+), 48 deletions(-)

diff --git a/drivers/mfd/tps65217.c b/drivers/mfd/tps65217.c
index 9d39d29..8346c28 100644
--- a/drivers/mfd/tps65217.c
+++ b/drivers/mfd/tps65217.c
@@ -33,6 +33,11 @@
 #include <linux/mfd/core.h>
 #include <linux/mfd/tps65217.h>
 
+#include <linux/reboot.h>
+
+static int power_off_on_battery = 1;
+static int power_off_timeout = 30;
+
 static const struct mfd_cell tps65217s[] = {
 	{
 		.name = "tps65217-pmic",
@@ -160,40 +165,59 @@ static const struct of_device_id tps65217_of_match[] = {
 	{ /* sentinel */ },
 };
 
+void (*pm_schedule_power_off)(unsigned long delay);
+EXPORT_SYMBOL(pm_schedule_power_off);
+
 static irqreturn_t tps65217_irq(int irq, void *irq_data)
 {
-        struct tps65217 *tps = irq_data;
-        unsigned int int_reg = 0, status_reg = 0;
-
-        tps65217_reg_read(tps, TPS65217_REG_INT, &int_reg);
-        tps65217_reg_read(tps, TPS65217_REG_STATUS, &status_reg);
-        if (status_reg)
-                dev_dbg(tps->dev, "status now: 0x%X\n", status_reg);
-
-        if (!int_reg)
-                return IRQ_NONE;
-
-        if (int_reg & TPS65217_INT_PBI) {
-                /* Handle push button */
-                dev_dbg(tps->dev, "power button status change\n");
-                input_report_key(tps->pwr_but, KEY_POWER,
-                                status_reg & TPS65217_STATUS_PB);
-                input_sync(tps->pwr_but);
-        }
-        if (int_reg & TPS65217_INT_ACI) {
-                /* Handle AC power status change */
-                dev_dbg(tps->dev, "AC power status change\n");
-                /* Press KEY_POWER when AC not present */
-                input_report_key(tps->pwr_but, KEY_POWER,
-                                ~status_reg & TPS65217_STATUS_ACPWR);
-                input_sync(tps->pwr_but);
-        }
-        if (int_reg & TPS65217_INT_USBI) {
-                /* Handle USB power status change */
-                dev_dbg(tps->dev, "USB power status change\n");
-        }
-
-        return IRQ_HANDLED;
+	struct tps65217 *tps = irq_data;
+	unsigned int int_reg = 0, status_reg = 0;
+	static int power_off_scheduled = 0;
+	int schedule_power_off = 0;
+	int on_battery;
+
+	tps65217_reg_read(tps, TPS65217_REG_INT, &int_reg);
+	tps65217_reg_read(tps, TPS65217_REG_STATUS, &status_reg);
+	if (status_reg)
+		dev_dbg(tps->dev, "status now: 0x%X\n", status_reg);
+
+	if (!int_reg)
+		return IRQ_NONE;
+
+	if (int_reg & TPS65217_INT_PBI) {
+		/* Handle push button */
+		dev_dbg(tps->dev, "power button status change\n");
+		input_report_key(tps->pwr_but, KEY_POWER, (status_reg & TPS65217_STATUS_PB));
+		input_sync(tps->pwr_but);
+		if (status_reg & TPS65217_STATUS_PB)
+			schedule_power_off = 1;
+	}
+
+	on_battery = !(status_reg & (TPS65217_STATUS_ACPWR | TPS65217_STATUS_USBPWR));
+	if (int_reg & (TPS65217_INT_ACI | TPS65217_INT_USBI)) {
+		/* Handle external power status change */
+		dev_dbg(tps->dev, "external power status change\n");
+		if (on_battery && power_off_on_battery) {
+			input_report_key(tps->pwr_but, KEY_POWER, 1);
+			input_report_key(tps->pwr_but, KEY_POWER, 0);
+			input_sync(tps->pwr_but);
+			schedule_power_off = 1;
+		}
+	}
+
+	if (schedule_power_off && !power_off_scheduled) {
+		power_off_scheduled = 1;
+		if (power_off_timeout > 1) {
+			/* schedule power off */
+			if (pm_schedule_power_off)
+				pm_schedule_power_off(power_off_timeout);
+		} else if (power_off_timeout == 1) {
+			/* immediate power off */
+			machine_power_off();
+		}
+	}
+
+	return IRQ_HANDLED;
 }
 
 static int tps65217_probe_pwr_but(struct tps65217 *tps)
@@ -385,6 +409,12 @@ static void __exit tps65217_exit(void)
 }
 module_exit(tps65217_exit);
 
+module_param(power_off_on_battery, int, 0644);
+MODULE_PARM_DESC(power_off_on_battery, "immediate shutdown on AC power loss");
+
+module_param(power_off_timeout, int, 0644);
+MODULE_PARM_DESC(power_off_timeout, "max. time for shutdown (in seconds)");
+
 MODULE_AUTHOR("AnilKumar Ch <anilkumar@ti.com>");
 MODULE_DESCRIPTION("TPS65217 chip family multi-function driver");
 MODULE_LICENSE("GPL v2");
diff --git a/drivers/rtc/rtc-omap.c b/drivers/rtc/rtc-omap.c
index 8e5851a..2bc0309 100644
--- a/drivers/rtc/rtc-omap.c
+++ b/drivers/rtc/rtc-omap.c
@@ -370,21 +370,7 @@ static int omap_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)
 
 static struct omap_rtc *omap_rtc_power_off_rtc;
 
-/*
- * omap_rtc_poweroff: RTC-controlled power off
- *
- * The RTC can be used to control an external PMIC via the pmic_power_en pin,
- * which can be configured to transition to OFF on ALARM2 events.
- *
- * Notes:
- * The two-second alarm offset is the shortest offset possible as the alarm
- * registers must be set before the next timer update and the offset
- * calculation is too heavy for everything to be done within a single access
- * period (~15 us).
- *
- * Called with local interrupts disabled.
- */
-static void omap_rtc_power_off(void)
+static void rtc_schedule_power_off(unsigned long delay)
 {
 	struct omap_rtc *rtc = omap_rtc_power_off_rtc;
 	struct rtc_time tm;
@@ -399,7 +385,8 @@ static void omap_rtc_power_off(void)
 	omap_rtc_read_time_raw(rtc, &tm);
 	bcd2tm(&tm);
 	rtc_tm_to_time(&tm, &now);
-	rtc_time_to_tm(now + 2, &tm);
+	/* Add shutdown time to the current value */
+	rtc_time_to_tm(now + delay, &tm);
 
 	if (tm2bcd(&tm) < 0) {
 		dev_err(&rtc->rtc->dev, "power off failed\n");
@@ -423,6 +410,25 @@ static void omap_rtc_power_off(void)
 	val = rtc_read(rtc, OMAP_RTC_INTERRUPTS_REG);
 	rtc_writel(rtc, OMAP_RTC_INTERRUPTS_REG,
 			val | OMAP_RTC_INTERRUPTS_IT_ALARM2);
+}
+
+/*
+ * omap_rtc_poweroff: RTC-controlled power off
+ *
+ * The RTC can be used to control an external PMIC via the pmic_power_en pin,
+ * which can be configured to transition to OFF on ALARM2 events.
+ *
+ * Notes:
+ * The two-second alarm offset is the shortest offset possible as the alarm
+ * registers must be set before the next timer update and the offset
+ * calculation is too heavy for everything to be done within a single access
+ * period (~15 us).
+ *
+ * Called with local interrupts disabled.
+ */
+static void omap_rtc_power_off(void)
+{
+	rtc_schedule_power_off(2);
 
 	/*
 	 * Wait for alarm to trigger (within two seconds) and external PMIC to
@@ -492,6 +498,7 @@ static int __init omap_rtc_probe(struct platform_device *pdev)
 	const struct platform_device_id *id_entry;
 	const struct of_device_id *of_id;
 	int ret;
+	u32 val;
 
 	rtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);
 	if (!rtc)
@@ -532,6 +539,10 @@ static int __init omap_rtc_probe(struct platform_device *pdev)
 		rtc_writel(rtc, OMAP_RTC_KICK1_REG, KICK1_VALUE);
 	}
 
+	/* Disable PMIC power enable */
+	val = rtc_readl(rtc, OMAP_RTC_PMIC_REG);
+	rtc_writel(rtc, val & ~OMAP_RTC_PMIC_POWER_EN_EN, OMAP_RTC_PMIC_REG);
+
 	/*
 	 * disable interrupts
 	 *
@@ -620,6 +631,7 @@ static int __init omap_rtc_probe(struct platform_device *pdev)
 			omap_rtc_power_off_rtc = rtc;
 			pm_power_off = omap_rtc_power_off;
 		}
+		pm_schedule_power_off = rtc_schedule_power_off;
 	}
 
 	return 0;
diff --git a/include/linux/pm.h b/include/linux/pm.h
index e2f1be6..bb432e4 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -33,6 +33,7 @@
  */
 extern void (*pm_power_off)(void);
 extern void (*pm_power_off_prepare)(void);
+extern void (*pm_schedule_power_off)(unsigned long delay);
 
 struct device; /* we have a circular dep with device.h */
 #ifdef CONFIG_VT_CONSOLE_SLEEP
-- 
2.1.4

